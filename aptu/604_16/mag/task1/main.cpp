//
// Automatically generated by Flow Graph Analyzer: C++ Code Generator Plugin version Alpha 5.15230
//

#include <iostream>
#include "tbb.h"
using namespace std;
mutex average_brightness_node_body::tlock;

void print_help()
{
    cout << "Help:" << endl;
    cout << "-b [0-255] - to set brightness for step 2" << endl;
    cout << "-l [0-65536] - number of images to be processed simultaneously" << endl;
    cout << "-f <filename> - to write logs to specified file" << endl;
    cout << "-m <filename> - to limit maximum number of files generated" << endl;
}

int main( int argc, char *argv[] ) {
    char opt;
    char exact_value = 123;
    unsigned short max_threads = 5;
    int max_input = 100;
    string filename = "";
    ofstream log;
    while (-1 != (opt = (char) getopt(argc, argv, "b:l:f:m:"))) {
        switch (opt) {
            case 'b':
                exact_value = (char) atoi(optarg);
                break;
            case 'l':
                max_threads = (unsigned short) atoi(optarg);
                break;
            case 'f':
                filename = optarg;
                if(!filename.empty()){
                    log.open(filename);
                }
                break;
            case 'm':
                max_input = atoi(optarg);
                break;
            default:
                cout << "Invalid arguments. See help below";
                print_help();
                return 1;
        }
    }
    graph model_g0;

    source_node< image > image_input_node(model_g0, image_input_node_body(max_input), false );
    limiter_node< image > Limit_input_node(model_g0, max_threads);
    function_node< image, vector<point> > max_node(model_g0, 1, max_node_body() );
    function_node< image, vector<point> > min_node(model_g0, 1, min_node_body() );
    function_node< image, vector<point> > exact_node(model_g0, 1, exact_node_body(exact_value) );
    broadcast_node< image > broadcast_image_node(model_g0);
    join_node< flow::tuple< image, vector<point>, vector<point>, vector<point> >> aggregator(model_g0);
    function_node< tbb::flow::tuple<image,vector<point>,vector<point>,vector<point>>, image > highlight_node(model_g0, 1, highlight_node_body() );
    broadcast_node< image > broadcast_marked_node(model_g0);
    function_node< image, int > average_brightness_node(model_g0, 1, average_brightness_node_body(filename, log) );
    function_node< image, int > inverse_image_node(model_g0, 1, inverse_image_node_body() );
    join_node< flow::tuple< int, int >> counter_join_node(model_g0);
    function_node< tbb::flow::tuple<int,int>, continue_msg > counter_node(model_g0, 1, counter_node_body() );
    make_edge( image_input_node, Limit_input_node);
    make_edge( Limit_input_node, broadcast_image_node);
    make_edge( broadcast_image_node, exact_node);
    make_edge( broadcast_image_node, min_node);
    make_edge( broadcast_image_node, max_node);
    make_edge( broadcast_image_node, input_port< 0 >( aggregator ));
    make_edge( max_node, input_port< 1 >( aggregator ));
    make_edge( min_node, input_port< 2 >( aggregator ));
    make_edge( exact_node, input_port< 3 >( aggregator ));
    make_edge( aggregator, highlight_node);
    make_edge( highlight_node, broadcast_marked_node);
    make_edge( broadcast_marked_node, average_brightness_node);
    make_edge( broadcast_marked_node, inverse_image_node);
    make_edge( inverse_image_node, input_port< 0 >( counter_join_node ));
    make_edge( average_brightness_node, input_port< 1 >( counter_join_node ));
    make_edge( counter_join_node, counter_node);
    make_edge( counter_node, Limit_input_node.decrement);
    image_input_node.activate();
    model_g0.wait_for_all();
    log.close();
    return 0;
}